
%% bare_conf.tex
%% V1.4a
%% 2014/09/17
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8a or later) with an IEEE
%% conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_conf_compsoc.tex,
%%                    bare_jrnl_compsoc.tex, bare_jrnl_transmag.tex
%%*************************************************************************

\documentclass[conference]{IEEEtran}

\hyphenation{op-tical net-works semi-conduc-tor}

\usepackage{xcolor}
\usepackage{float}


\begin{document}
	
\title{Understanding Asymmetric Encryption Algorithms}


\author{\IEEEauthorblockN{Colin MacCreery}
	\IEEEauthorblockA{Western Michigan University\\
		College of Engineering\\
		Computer Science Department \\
		Kalamazoo, Michigan\\
		Email: colin.c.maccreery@wmich.edu}
\and
\IEEEauthorblockN{Jason Pearson}
\IEEEauthorblockA{Western Michigan University\\
	College of Engineering\\
	Computer Science Department \\
Kalamazoo, Michigan\\
Email: jason.j.pearson@wmich.edu}}

\maketitle

\begin{abstract}
	This paper contains information on how various cryptology algorithms work including RSA public key encryption, ElGamal asymmetric cryptology and Elliptic Curve public key encryption. 
\end{abstract}

\IEEEpeerreviewmaketitle



\section{Introduction} \color{red}
Writing an introduction sentence is hard. 

\color{black}
\subsection{Types of Encryption}


\subsubsection{Asymmetric Encryption}
Asymmetric encryption is also known as public key cryptography. These public key systems work by having a public key and a private key. The duty of the public key is to encrypt a message. The encrypted message is only able to be decrypted by an appropriate private key. One major down side of public key systems is that creating the key tends to be computationally expensive. 
\subsubsection{Symmetric Encryption}
Symmetric encryption uses a single key for encryption and decryption. The keys on both sides are not always identical but both can encrypt and decrypt a message. Typically a symmetric encryption uses one of two methods stream ciphers or block ciphers. Stream ciphers encrypt data as it comes typically a few bytes at a time. For block ciphers a number of bits is taken at a time and is encrypted. If the data is too small to fit into a block it is padded so that it can fit into a block. Some common algorithms that use symmetric encryption are AES and blowfish.

\subsubsection{Hashing} \color{red}
Do we want to talk about hashing? Hashing isn't exactly a method of encryption but uses encryption ideas to create secure fields. could be used for more filler maybe?
\color{black}
\subsubsection{Hybrid Cryptosystems}
Hybrid cryptosystems use both asymmetric and symmetric encryption schemes. A hybrid system works by encrypting the message with a symmetric encryption key. This key is then encrypted using an asymmetric encryption technique. The symmetric key is then appended to the message. The benefit of using two encryption methods is that less time is needed for encrypting and decrypting the message due to using a symmetric technique plus since the symmetric key is encrypted using an asymmetric method we can still get the security of a public private key pair. A new symmetric key is generated each time to improve security further. 

\color{red}
\subsection{Dependant (Dependent?) Algorithms}
There are many algorithms that different forms of cryptography rely on.
This could be like an appendix type area maybe?
I want to try and keep the algorithm talk less cluttered by talking about the parts they depend on first.
then in the algorithm section we can focus on that we already explained what the underlying parts are here is the algorithm.

\subsubsection{AKS Primality Test}
Do we need to go into detail of algorithms that our algorithm is Dependant on?
Maybe we make this section to help fill space up and make us look smart?

\subsubsection{Cyclic Groups}
integer and modular addition --> related to eulers totient function
what all of rsa is based on more or less
define gcd and modular exponentiation
\newline
cyclic groups are also used by elgamal i have discovered

\subsubsection{Euler's Totient Function}
used in the rsa algorithm for something

\subsubsection{Padding Schemes}
I bet a lot of these will need padding schemes and we should probably have a talk about this


\subsubsection{Extended Euclidean Algorithm}
This is used in rsa for creating a decryption key

\color{black}


\section{RSA Asymmetric Cryptography}


The RSA asymmetric cryptography algorithm is named after its creators Ron Rivest, Adi Shamir and Leonard Adleman and was first thought of in 1973. 
At the time it was highly classified and was not declassified until 1997.
The idea behind this algorithm is to use large prime numbers to create a public key and a private key. 
Security for this algorithm rises from the difficulty of factoring large integers.
 
\subsection{Private and Public Key Generation}
The key generation process is a five step process. 

\subsubsection{Creating Large Prime Numbers}
First two large prime numbers are calculated using a prime number testing algorithm such as AKS. These will be denoted p and q. We want both of these values to be relatively the same length digit wise but it can differ a bit. 

\subsubsection{Compute n}
Computing n is just the product of p and q. The value of n will be used as the modulus for our keys and it's length is known as the key length.

\begin{figure}[h]
	\begin{center}
		$n=p * q$
	\end{center}
\end{figure}

\subsubsection{Compute Euler's Totient Function}
Now we must use Euler's totient function to give us a max value for our public key e.
Luckily we are able to use algebra to make computing this value much easier.
\begin{figure}[h]
	\begin{center}
		$\phi \left(n\right)=\phi \left(p\right)\phi \left(q\right)=\left(p-1\right)\left(q-1\right)=n-\left(p+q-1\right)$
	\end{center}
\end{figure}

\subsubsection{Create Public Key}
Now we need to create a value for e which will be our public key exponent for encrypting a message. For this value we want to use a reasonably small value without it being too small. 
\begin{figure}[h]
	\begin{center}
		$1 < e < \phi \left(n\right)$
	\end{center}
\end{figure}
\subsubsection{Create Private Key}
Lastly since we have generated a value for e we will create d which will be used for decryption. To generate d we compute the modular multiplicative inverse of e (modulo $ \phi \left(n\right))$. This value is commonly computed using the Extended Euclidean Algorithm. This is represented by the equation below.
\begin{figure}[h]
	\begin{center}
		$d\equiv {e}^{-1}\left(\mathrm{mod}\left(\phi \left(n\right)\right)\right)$
	\end{center}
\end{figure}




\subsection{Encrypting and Decrypting a Message}

With the values of e and d determined the next step is to use this key pair to encrypt and decrypt a cipher text. To start a message we need to convert it's text into a number. This is done by the use of ASCII values and by using an agreed upon padding scheme. To compute a ciphertext c and restore it to a readable message we use the following equations respectively.

\begin{figure}[H]
	\begin{center}
		$c\equiv {m}^{e}\left(mod\left(n\right)\right)$ and
		$m\equiv {c}^{d}\left(mod\left(n\right)\right)$
	\end{center}
\end{figure}

\subsection{Example of Usage}
\subsubsection{Creating Large Prime Numbers}
To start with an example we will need to prime numbers for p and q. This example will be a simple one so smaller prime numbers are used. Let p = 991 and q = 821. 
\subsubsection{Compute N}
We then use p and q to determine our value for n. Since $n = p * q$ this makes the value of n = 813611.
\subsubsection{Compute Euler's Totient} 
Compute the Euler's totient value next.
\begin{figure}[h]
	\begin{center}
$\phi \left(813611\right)=\phi \left(991\right)\phi \left(821\right)=\left(990\right)\left(820\right)=813611-\left(1811\right) = 811800$
\end{center}
\end{figure} 
\subsubsection{Create Public Key}
With these values created a public and private key can be created. Let e = 7423 which was arbitrarily chosen and now d is computed.
\subsubsection{Create Private Key} 
Using the extended Euclidean algorithm to compute the modular multiplicative inverse we get d = 788287. The values of d and e are our private and public keys respectively and can now be used for message encryption/decryption. \newline \indent
Let our plain text message m = "Hi". First we use an ASCII table to determine the value of m as a large integer. A simple way to do this is to concatenate each ASCII value together to form the integer. So m = 72105. Now that we have all the values we need we can encrypt and decrypt a message
\begin{figure}[h]
	\begin{center}
		$c \equiv {72105}^{7423} mod (813611)$ \newline
		$c = 707473$ \newline
		$m \equiv {707473}^{788287} mod (813611)$ \newline
		$m = 72105$ \newline
	\end{center}
\end{figure}

The ASCII values for our message 'Hi' were 72 and 105 so that means it was successfully decrypted. 


\color{red}
\subsection{Security Concerns}

\subsection{Discussion}


\color{black}

%% -------------------------------- Break point for next algorithm --------------------------------

\section{ElGamal Asymmetric Cryptography}
ElGamal public key cryptography is an alternative to RSA. This encryption algorithm was first described by Taher Elgmal in 1985. The ElGamal algorithm is dependent on the difficulty of computing discrete logs in a large prime modulus.

\subsection{Private and Public Key Generation}
The first step is to create a large prime number p. This p will be the exclusive max in our cyclic group. After p is generated an arbitrary number g that is between 1 and p - 1 is created. The variable g is the generator for our cyclic group. Then one last number x is selected where x is between 1 and p - 1, x will be used as the private key. We now compute a y value which will be the last part of our public key which is (p,g,y). To compute y see the next figure.

\begin{figure}[h]
	\begin{center}
		$y={g}^{x}\mathrm{mod}p$
	\end{center}	
\end{figure}


\subsection{Encrypting and Decrypting a Message}

When using ElGamal for encryption the cipher text will be twice the length of the plain text message. 
To encrypt first a random value k is chosen where k is between 1 and q - 1. Each time a message is sent the value of k should be changed. The message is then broken up into chunks and a padding scheme is followed so that the string is less than our value of p. Now for each chunk of the message m to be encrypted we create an ordered pair (a,b) by using the following equations.

\begin{figure}[h]
	\begin{center}
		$a={g}^{k}mod\left(p\right)$ \newline
		$b={y}^{k}\left(m\right)mod\left(p\right)$ \newline
	\end{center}
\end{figure}

A series of these order pairs are sent then to the receiver who can then decrypt them and assemble the message. To decrypt each ordered pair we can use the following equations.

\begin{figure}[H]
	\begin{center}
		$s={a}^{x}$ \newline
		$m=b * {s}^{-1} mod\left(p\right)$ \newline
	\end{center}
\end{figure}


\subsection{Example of Usage}

\color{red}
\subsection{Security Concerns}

\subsection{Discussion}

\section{Elliptic Curve Asymmetric Cryptography}

\subsection{Private and Public Key Generation}

\subsection{Encrypting and Decrypting a Message}

\subsection{Example of Usage}

\subsection{Security Concerns}
\subsection{Discussion}



\section{Comparison}
Here would be a good spot to compare and contrast all of them. this is the area that i think he wants us to focus on but I don't know


\section{Conclusion}
The conclusion goes here.


\section*{Acknowledgment}

I don't plan on having acknowledgments but since it is in the template i will leave it here for now




% %\begin{thebibliography}{1}

\section{References}
\subsection{General References}
http://mathworld.wolfram.com/CyclicGroup.html \newline
http://www.cs.princeton.edu/~dsri/modular-inversion-answer.php \newline
https://eprint.iacr.org/2012/195.pdf \newline

\subsection{RSA References}
http://doctrina.org/Why-RSA-Works-Three-Fundamental-Questions-Answered.html \newline


\subsection{ElGamal References}
https://asecuritysite.com/encryption/elgamal \newline
http://homepages.math.uic.edu/~leon/mcs425-s08/handouts/el-gamal.pdf \newline
http://www.nku.edu/~christensen/1002mat584ElGamal%20example%20appendix.pdf \newline

\subsection{Elliptic Curve References}

% %#\bibitem{IEEEhowto:kopka}
% %H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
  % %0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

% %\end{thebibliography}


\end{document}


